<script>
	import { onMount } from 'svelte';
	import SimplexNoise from 'simplex-noise';
	import { PI, cream, fog, green, colors, createGrid, Circle } from '$lib/utils/canvas';
	import smplx from '$lib/data/smplx.json';

	let animationFrame,
		canvas,
		columns,
		container,
		ctx,
		cR,
		field,
		rows,
		scale,
		simplex,
		size,
		wX,
		wY;
	let time = 0;
	const inc = 0.003;
	let circles = [];

	function setup() {
		scale = 1;
		wX = container.offsetWidth;
		wY = container.offsetHeight;
		size = wX < 600 ? 20 : 24;
		canvas.style.width = wX + 'px';
		canvas.style.height = wY + 'px';
		canvas.width = wX * scale;
		canvas.height = wY * scale;
		ctx.scale(scale, scale);
		columns = createGrid(wX, size);
		rows = createGrid(wY, size);
		initField();
		cR = (wX / 3) * 2;
	}

	function draw() {
		animationFrame = window.requestAnimationFrame(draw);
		calculateField();
		clear();
		drawField();
		drawCircles();
		time += inc;
	}

	// setup the grid of vectors
	function initField() {
		field = new Array(columns);
		for (let x = 0; x < columns; x++) {
			field[x] = new Array(rows);
			for (let y = 0; y < rows; y++) {
				field[x][y] = [0, 0];
			}
		}
	}

	// run the animation
	function drawField() {
		for (let x = 0; x < columns; x++) {
			for (let y = 0; y < rows; y++) {
				const angle = field[x][y][0];
				const length = field[x][y][1];
				ctx.save();
				ctx.translate(x * size, y * size);
				ctx.rotate(angle);
				ctx.strokeStyle = green;
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(0, size * length);
				ctx.stroke();
				ctx.restore();
			}
		}
	}

	// clear the canvas at the beginning of each frame
	function clear() {
		ctx.fillStyle = fog;
		ctx.fillRect(0, 0, wX, wY);
	}

	// calculate each frame of the animation
	function calculateField() {
		for (let x = 0; x < columns; x++) {
			for (let y = 0; y < rows; y++) {
				const angle = simplex.noise3D(x / 50, y / 50, time) * (PI * 2);
				console.log(angle);
				const length = simplex.noise3D(x / 100 + 40000, y / 100 + 40000, time);
				field[x][y][0] = angle;
				field[x][y][1] = length;
			}
		}
	}

	function createCircles() {
		for (let i = 0; i < 2; i++) {
			circles.push(new Circle(colors[i]));
		}
	}

	function drawCircles() {
		const sine = [Math.sin(time) * (wX / 2) + wX / 2, Math.sin(time + PI) * (wX / 2) + wX / 2];
		const cosine = [Math.cos(time) * (wX / 2) + wX / 2, Math.cos(time + PI) * (wX / 2) + wX / 2];
		for (const [i, circle] of circles.entries()) {
			circle.update(sine[i], cosine[i]);
			circle.show(ctx, cR);
		}
	}

	onMount(() => {
		simplex = new SimplexNoise(100, 100, 100);

		ctx = canvas.getContext('2d');
		setup();
		createCircles();
		animationFrame = window.requestAnimationFrame(draw);

		return () => window.cancelAnimationFrame(animationFrame);
	});
</script>

<section class="hero">
	<div bind:this={container} class="container">
		<canvas bind:this={canvas} id="canvas" width="400" height="400" />
	</div>
</section>

<style>
	section.hero {
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100%;
		min-height: 100vh;
		background: #f9f6ee;
	}

	div.container {
		width: 80vh;
		height: 80vh;
		aspect-ratio: 1/1;
		border-radius: 50%;
		overflow: hidden;
		/* background: green; */
	}

	canvas {
		display: block;
	}
</style>
